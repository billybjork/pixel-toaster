#!/usr/bin/env python3
import argparse
import logging
import sys
import json
import shlex

from file_manager import FileManager
from command_generator import CommandGenerator
from command_executor import CommandExecutor

def print_art():
    art = r"""
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣄⠀⠀⠀⢀⡀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣟⠁⠀⠀⣴⡏⠁⠀⠀⣾⡋⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⠄⠀⠈⠻⠷⠀⠀⠈⢹⣷⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣤⣤⣤⣤⣤⣤⣀⠀⠠⣤⣀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣹⣿⡿⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠛⠀⠛⠛⠛⠛⠉⠛⠛⠛⠀⠐⠛⠛⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⠸⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠏⢠⣾⣿⣦⠘⠇⠀⠀
⠀⠀⢀⣤⡀⠀⢰⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣆⠘⢿⣿⠟⢠⡆⠀⠀
⠀⠀⠘⠛⠛⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣤⣶⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢠⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠀⠀⠀⠀
"""
    print(art)

def main():
    parser = argparse.ArgumentParser(
        description="pixl-toastr: Natural language FFmpeg command generator."
    )
    parser.add_argument("query", nargs="+", help="Your natural language prompt for FFmpeg.")
    parser.add_argument("--dry-run", action="store_true", help="Show the generated command without executing it.")
    parser.add_argument("--file", type=str, help="Specify an input file explicitly.")
    parser.add_argument("--confirm", action="store_true", help="Ask for confirmation before executing the command.")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose output.")
    args = parser.parse_args()

    # Configure logging with a timestamp.
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format="%(asctime)s - %(levelname)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )

    # Instantiate helper classes.
    file_manager = FileManager()
    command_generator = CommandGenerator()
    command_executor = CommandExecutor()

    user_query = " ".join(args.query)
    logging.info(f"Interpreting your request: {user_query}")

    # --- File Handling ---
    detected_file = None
    if args.file:
        logging.info(f"Using explicit file: {args.file}")
        detected_file = args.file
        user_query += f"\n(Use the file '{args.file}' as input.)"
    else:
        ext_set, explicit_file = file_manager.analyze_prompt_for_filetype(user_query)
        if explicit_file:
            logging.info(f"Found explicit file in query: {explicit_file}")
            detected_file = explicit_file
        elif ext_set is not None:
            found_file = file_manager.detect_single_file(ext_set)
            if found_file:
                logging.info(f"Found a single matching file: {found_file}")
                detected_file = found_file
                user_query += f"\n(We found a single file named '{found_file}' in the directory. Please use that as input.)"
            else:
                files = file_manager.list_files(ext_set)
                if files:
                    logging.info(f"Found multiple matching files: {', '.join(files)}")
                    file_list_str = ", ".join(files)
                    user_query += f"\n(Found these files in the directory: {file_list_str}. Please use all of them as inputs.)"
                    detected_file = files

        # --- Fuzzy and Normalized Matching Fallbacks ---
        if not detected_file:
            fuzzy_file = file_manager.fuzzy_match_filename(user_query)
            if fuzzy_file:
                logging.info(f"Fuzzy matched file: {fuzzy_file}")
                detected_file = fuzzy_file
                user_query += f"\n(Using fuzzy matched file '{fuzzy_file}' as input.)"
        if not detected_file:
            norm_file = file_manager.normalized_match_filename(user_query)
            if norm_file:
                logging.info(f"Normalized matched file: {norm_file}")
                detected_file = norm_file
                user_query += f"\n(Using normalized matched file '{norm_file}' as input.)"

    # --- Command Generation with Retries ---
    attempt = 0
    error_message = None
    ffmpeg_command = None

    while attempt < command_generator.max_retries:
        attempt += 1
        logging.info(f"--- Attempt #{attempt} ---")
        raw_response = command_generator.generate_command(user_query, error_message)
        logging.debug(f"LLM raw response: {raw_response}")
        cleaned_json = command_generator.clean_json_response(raw_response)
        logging.debug(f"LLM cleaned response: {cleaned_json}")

        try:
            parsed = json.loads(cleaned_json)
            ffmpeg_command = parsed.get("command", "").strip()
        except Exception as e:
            logging.error("Failed to parse JSON response from LLM.")
            error_message = f"JSON parse error: {e}. Original response: {raw_response}"
            continue

        if not ffmpeg_command or not ffmpeg_command.startswith("ffmpeg"):
            logging.error("Invalid command received from LLM:")
            logging.error(cleaned_json)
            error_message = f"Invalid command: {cleaned_json}"
            continue

        # --- Adjust the Command Based on the File(s) ---
        if detected_file:
            if isinstance(detected_file, str):
                ffmpeg_command = command_generator.replace_placeholder_with_file(ffmpeg_command, detected_file)
                ffmpeg_command = command_generator.update_output_filename(ffmpeg_command, detected_file)
            elif isinstance(detected_file, list):
                # Check if the query implies an individual transformation (e.g. "flip", "trim", etc.)
                if any(keyword in user_query.lower() for keyword in ["flip", "rotate", "trim", "compress"]):
                    # For example, if flipping is requested, manually build a per-file command.
                    # Here, we specifically handle "flip" (upside down means vflip).
                    if "flip" in user_query.lower():
                        for f in detected_file:
                            import os, shlex
                            base, ext = os.path.splitext(f)
                            output_name = f"{base}_toasted{ext}"
                            cmd = f"ffmpeg -i {shlex.quote(f)} -vf vflip {shlex.quote(output_name)}"
                            logging.info(f"Executing flip command for file {f}: {cmd}")
                            success, output = command_executor.execute_with_retries(cmd, args.confirm, args.dry_run)
                            if not success:
                                logging.error(f"Command failed for {f}: {output}")
                        sys.exit(0)
                    # Otherwise, if no special transformation detected, you can either:
                    # a) Concatenate (if that was the intended operation)
                    # b) Or process individually – here we choose to process individually.
                    for f in detected_file:
                        per_file_cmd = command_generator.replace_placeholder_with_file(ffmpeg_command, f)
                        per_file_cmd = command_generator.update_output_filename(per_file_cmd, f)
                        logging.info(f"Executing command for file {f}: {per_file_cmd}")
                        success, output = command_executor.execute_with_retries(per_file_cmd, args.confirm, args.dry_run)
                        if not success:
                            logging.error(f"Command failed for {f}: {output}")
                    sys.exit(0)
        ffmpeg_command = command_generator.fix_command_quotes(ffmpeg_command)
        logging.info(f"Proposed command: {ffmpeg_command}")

        # --- Execute the Command ---
        success, output = command_executor.execute_with_retries(ffmpeg_command, args.confirm, args.dry_run)
        if success:
            logging.info("Command executed successfully!")
            logging.debug(f"Command output: {output}")
            print_art()
            sys.exit(0)
        else:
            logging.error("Command execution failed, retrying...")
            error_message = output

    logging.error("Maximum retries exceeded. Exiting with error.")
    sys.exit(1)

if __name__ == "__main__":
    main()