#!/usr/bin/env python3
import argparse
import logging
import sys
import json
import shlex
import re

from file_manager import FileManager, VIDEO_EXTENSIONS
from command_generator import CommandGenerator
from command_executor import CommandExecutor

def print_art():
    art = r"""
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣄⠀⠀⠀⢀⡀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣟⠁⠀⠀⣴⡏⠁⠀⠀⣾⡋⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⠄⠀⠈⠻⠷⠀⠀⠈⢹⣷⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣤⣤⣤⣤⣤⣤⣀⠀⠠⣤⣀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣹⣿⡿⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠛⠀⠛⠛⠛⠛⠉⠛⠛⠛⠀⠐⠛⠛⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⠸⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠏⢠⣾⣿⣦⠘⠇⠀⠀
⠀⠀⢀⣤⡀⠀⢰⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣆⠘⢿⣿⠟⢠⡆⠀⠀
⠀⠀⠘⠛⠛⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣤⣶⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢠⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠀⠀⠀⠀
"""
    print(art)

def main():
    parser = argparse.ArgumentParser(
        description="pixl-toastr: Natural language FFmpeg command generator."
    )
    parser.add_argument("query", nargs="+", help="Your natural language prompt for FFmpeg.")
    parser.add_argument("--dry-run", action="store_true", help="Show the generated command without executing it.")
    parser.add_argument("--file", type=str, help="Specify an input file explicitly.")
    parser.add_argument("--confirm", action="store_true", help="Ask for confirmation before executing the command.")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose output.")
    args = parser.parse_args()

    # Configure logging with a timestamp.
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format="%(asctime)s - %(levelname)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )

    # Instantiate helper classes.
    file_manager = FileManager()
    command_generator = CommandGenerator()
    command_executor = CommandExecutor()

    user_query = " ".join(args.query)
    logging.info("Interpreting your request: %s", user_query)

    # --- Conversion Request Detection ---
    desired_output_ext = None
    lower_query = user_query.lower()

    # Priority: detect conversion to GIF.
    if re.search(r'\bto\s+(?:a\s+)?gif\b', lower_query):
        desired_output_ext = ".gif"
        logging.info("Detected conversion request: output to .gif")
    # Detect image conversion requests like "convert the image files to jpg"
    elif re.search(r'convert\s+(?:the\s+)?image\s+files?\s+to\s+(\w+)', lower_query):
        match = re.search(r'convert\s+(?:the\s+)?image\s+files?\s+to\s+(\w+)', lower_query)
        dst_ext = match.group(1)
        desired_output_ext = f".{dst_ext}"
        logging.info(f"Detected conversion request: image files to {desired_output_ext}")
    else:
        # Existing conversion detection (e.g. "convert all mp4 files to mov")
        conv_match = re.search(r'convert\s+all\s+(\w+)\s+files?\s+to\s+(\w+)', lower_query)
        if conv_match:
            src_ext, dst_ext = conv_match.groups()
            desired_output_ext = f".{dst_ext}"
            logging.info(f"Detected conversion request: from .{src_ext} to {desired_output_ext}")

    # --- Trim Duration Extraction ---
    trim_duration = None
    trim_match = re.search(r'trim.*?(\d+)\s*sec', lower_query)
    if trim_match:
        trim_duration = trim_match.group(1)
        logging.info(f"Detected trim duration: {trim_duration} seconds")

    # --- File Handling ---
    detected_file = None
    if args.file:
        logging.info(f"Using explicit file: {args.file}")
        detected_file = args.file
        user_query += f"\n(Use the file '{args.file}' as input.)"
    else:
        ext_set, explicit_file = file_manager.analyze_prompt_for_filetype(user_query)
        if explicit_file:
            logging.info(f"Found explicit file in query: {explicit_file}")
            detected_file = explicit_file
        elif ext_set is not None:
            found_file = file_manager.detect_single_file(ext_set)
            if found_file:
                logging.info(f"Found a single matching file: {found_file}")
                detected_file = found_file
                user_query += f"\n(We found a single file named '{found_file}' in the directory. Please use that as input.)"
            else:
                files = file_manager.list_files(ext_set)
                if files:
                    logging.info(f"Found multiple matching files: {', '.join(files)}")
                    file_list_str = ", ".join(files)
                    user_query += f"\n(Found these files in the directory: {file_list_str}. Please use all of them as inputs.)"
                    detected_file = files

        # --- Fuzzy and Normalized Matching Fallbacks ---
        if not detected_file:
            fuzzy_file = file_manager.fuzzy_match_filename(user_query)
            if fuzzy_file:
                logging.info(f"Fuzzy matched file: {fuzzy_file}")
                detected_file = fuzzy_file
                user_query += f"\n(Using fuzzy matched file '{fuzzy_file}' as input.)"
        if not detected_file:
            norm_file = file_manager.normalized_match_filename(user_query)
            if norm_file:
                logging.info(f"Normalized matched file: {norm_file}")
                detected_file = norm_file
                user_query += f"\n(Using normalized matched file '{norm_file}' as input.)"

    # --- Command Generation with Retries ---
    attempt = 0
    error_message = None
    ffmpeg_command = None

    while attempt < command_generator.max_retries:
        attempt += 1
        logging.info(f"--- Attempt #{attempt} ---")
        raw_response = command_generator.generate_command(user_query, error_message)
        logging.debug(f"LLM raw response: {raw_response}")
        cleaned_json = command_generator.clean_json_response(raw_response)
        logging.debug(f"LLM cleaned response: {cleaned_json}")

        try:
            parsed = json.loads(cleaned_json)
            ffmpeg_command = parsed.get("command", "").strip()
        except Exception as e:
            logging.error("Failed to parse JSON response from LLM.")
            error_message = f"JSON parse error: {e}. Original response: {raw_response}"
            continue

        if not ffmpeg_command or not ffmpeg_command.startswith("ffmpeg"):
            logging.error("Invalid command received from LLM:")
            logging.error(cleaned_json)
            error_message = f"Invalid command: {cleaned_json}"
            continue

        # --- Adjust the Command Based on the File(s) ---
        if detected_file:
            if isinstance(detected_file, str):
                ffmpeg_command = command_generator.replace_placeholder_with_file(ffmpeg_command, detected_file)
                ffmpeg_command = command_generator.update_output_filename(ffmpeg_command, detected_file, desired_ext=desired_output_ext)
            elif isinstance(detected_file, list):
                if any(keyword in user_query.lower() for keyword in ["rotate", "trim", "compress", "convert"]):
                    if "trim" in user_query.lower():
                        duration = trim_duration if trim_duration is not None else "5"
                        for f in detected_file:
                            import os, shlex
                            _, ext = os.path.splitext(f)
                            if ext.lower() in VIDEO_EXTENSIONS:
                                base = os.path.splitext(f)[0]
                                out_ext = desired_output_ext if desired_output_ext and desired_output_ext != ext.lower() else ext
                                output_name = f"{base}_toasted{out_ext}"
                                if desired_output_ext and desired_output_ext != ext.lower():
                                    cmd = f"ffmpeg -i {shlex.quote(f)} -t {duration} {shlex.quote(output_name)}"
                                else:
                                    cmd = f"ffmpeg -i {shlex.quote(f)} -t {duration} -c copy {shlex.quote(output_name)}"
                                logging.info(f"Executing trim command for video file {f}: {cmd}")
                                success, output = command_executor.execute_with_retries(cmd, args.confirm, args.dry_run)
                                if not success:
                                    logging.error(f"Command failed for {f}: {output}")
                            else:
                                logging.info(f"Skipping file {f} as it is not recognized as a video for trimming.")
                        print_art()
                        sys.exit(0)
                    for f in detected_file:
                        per_file_cmd = command_generator.replace_placeholder_with_file(ffmpeg_command, f)
                        per_file_cmd = command_generator.update_output_filename(per_file_cmd, f, desired_ext=desired_output_ext)
                        logging.info(f"Executing command for file {f}: {per_file_cmd}")
                        success, output = command_executor.execute_with_retries(per_file_cmd, args.confirm, args.dry_run)
                        if not success:
                            logging.error(f"Command failed for {f}: {output}")
                    print_art()
                    sys.exit(0)
        ffmpeg_command = command_generator.fix_command_quotes(ffmpeg_command)
        logging.info(f"Proposed command: {ffmpeg_command}")

        # --- Execute the Command ---
        success, output = command_executor.execute_with_retries(ffmpeg_command, args.confirm, args.dry_run)
        if success:
            logging.info("Command executed successfully!")
            logging.debug(f"Command output: {output}")
            print_art()
            sys.exit(0)
        else:
            logging.error("Command execution failed, retrying...")
            error_message = output

    logging.error("Maximum retries exceeded. Exiting with error.")
    sys.exit(1)

if __name__ == "__main__":
    main()